needs std.math
needs std.io
needs font

// CPU state
pub let mut memory = Array<Int>(4096)
pub let mut V = Array<Int>(16)

let mut I_reg = 0
let mut pc = 0x200
let mut stack = Array<Int>(16)

let mut sp = 0
let mut delay_timer = 0
let mut sound_timer = 0

// 64x32 pixels, 0 or 1
pub let mut display = Array<Int>(2048)
// Keypad 16 keys, 0 or 1
pub let mut keys = Array<Int>(16)

// internal flags
let mut draw_flag = false
let mut waiting_for_key = false
let mut key_reg = 0


pub fn init() {
    font.load_font(memory)
}

@no_gc
pub fn should_draw() {
    if draw_flag {
        draw_flag = false
        return true
    }
    return false
}

pub fn is_waiting() {
    return waiting_for_key
}

@no_gc
pub fn tick_timers() {
    if delay_timer > 0 {
        delay_timer = delay_timer - 1
    }
    if sound_timer > 0 {
        sound_timer = sound_timer - 1
    }
}

@no_gc
pub fn cycle() {
    // FX0A: waiting for key press
    if waiting_for_key {
        for k in 0..16 {
            if keys[k] == 1 {
                V[key_reg] = k
                waiting_for_key = false
                return
            }
        }
        return
    }

    // bounds check
    if pc >= 4094 {
        return
    }

    // fetch opcode (2 bytes, big-endian)
    let opcode = (memory[pc] << 8) | memory[pc + 1]
    pc = pc + 2

    // decode the fields
    let nib = (opcode >> 12) & 0xF
    let x = (opcode >> 8) & 0xF
    let y = (opcode >> 4) & 0xF
    let n = opcode & 0xF
    let nn = opcode & 0xFF
    let nnn = opcode & 0xFFF

    // dispatch loop
    if nib == 0x0 {
        // 00E0 clear screen
        if opcode == 0x00E0 {
            for i in 0..2048 {
                display[i] = 0
            }
            draw_flag = true

        } else if opcode == 0x00EE {
            // 00EE return from subroutine
            sp = sp - 1
            pc = stack[sp]
        }

    } else if nib == 0x1 { 
        // 1NNN jump to NNN
        pc = nnn
    } else if nib == 0x2 {
        // 2NNN call subroutine at NNN
        stack[sp] = pc
        sp = sp + 1
        pc = nnn
    } else if nib == 0x3 {
        // 3XNN skip next if VX == NN
        if V[x] == nn {
            pc = pc + 2
        }

    } else if nib == 0x4 {
        // 4XNN skip next if VX != NN
        if V[x] != nn {
            pc = pc + 2
        }

    } else if nib == 0x5 {
        // 5XY0 skip next if VX == VY
        if V[x] == V[y] {
            pc = pc + 2
        }

    } else if nib == 0x6 {
        // 6XNN set VX = NN
        V[x] = nn

    } else if nib == 0x7 {
        // 7XNN add VX += NN (no carry flag)
        V[x] = (V[x] + nn) & 0xFF

    } else if nib == 0x8 {
        if n == 0x0 {
            // 8XY0 VX = VY
            V[x] = V[y]
        } else if n == 0x1 {
            // 8XY1 VX |= VY
            V[x] = V[x] | V[y]
        } else if n == 0x2 {
            // 8XY2 VX &= VY
            V[x] = V[x] & V[y]
        } else if n == 0x3 {
            // 8XY3 VX ^= VY
            V[x] = V[x] ^ V[y]
        } else if n == 0x4 {
            // 8XY4 VX += VY, VF = carry
            let sum = V[x] + V[y]
            V[x] = sum & 0xFF
            if sum > 255 {
                V[0xF] = 1
            } else {
                V[0xF] = 0
            }
        } else if n == 0x5 {
            // 8XY5 VX -= VY, VF = NOT borrow
            let vx = V[x]
            let vy = V[y]
            V[x] = (vx - vy) & 0xFF
            if vx >= vy {
                V[0xF] = 1
            } else {
                V[0xF] = 0
            }
        } else if n == 0x6 {
            // 8XY6 VX >>= 1, VF = LSB before shift
            let original = V[x]
            V[x] = (original >> 1) & 0xFF
            V[0xF] = original & 1
        } else if n == 0x7 {
            // 8XY7 VX = VY - VX, VF = not borrow
            let vx = V[x]
            let vy = V[y]
            V[x] = (vy - vx) & 0xFF
            if vy >= vx {
                V[0xF] = 1
            } else {
                V[0xF] = 0
            }
        } else if n == 0xE {
            // 8XYE VX <<= 1, VF = MSB before shift
            let original = V[x]
            V[x] = (original << 1) & 0xFF
            V[0xF] = (original >> 7) & 1
        }

    } else if nib == 0x9 {
        // 9XY0 skip next if VX != VY
        if V[x] != V[y] {
            pc = pc + 2
        }

    } else if nib == 0xA {
        // ANNN set I = NNN
        I_reg = nnn

    } else if nib == 0xB {
        // BNNN jump to NNN + V0
        pc = nnn + V[0]

    } else if nib == 0xC {
        // CXNN VX = random & NN
        V[x] = math.randint(0, 255) & nn

    } else if nib == 0xD {
        // DXYN draw sprite at (VX, VY), N rows tall
        let start_x = V[x] % 64
        let start_y = V[y] % 32
        V[0xF] = 0

        for row in 0..n {
            let py = start_y + row
            if py >= 32 { break }

            let sprite_byte = memory[I_reg + row]

            for col in 0..8 {
                let px = start_x + col
                if px >= 64 { break }

                if (sprite_byte & (0x80 >> col)) != 0 {
                    let idx = py * 64 + px
                    if display[idx] == 1 {
                        V[0xF] = 1
                    }
                    display[idx] = display[idx] ^ 1
                }
            }
        }
        draw_flag = true

    } else if nib == 0xE {
        if nn == 0x9E {
            // EX9E skip next if key VX is pressed
            if keys[V[x] & 0xF] == 1 {
                pc = pc + 2
            }
        } else if nn == 0xA1 {
            // EXA1 skip next if key VX is NOT pressed
            if keys[V[x] & 0xF] != 1 {
                pc = pc + 2
            }
        }

    } else if nib == 0xF {
        if nn == 0x07 {
            // FX07 VX = delay timer
            V[x] = delay_timer
        } else if nn == 0x0A {
            // FX0A wait for key press, store in VX
            waiting_for_key = true
            key_reg = x
        } else if nn == 0x15 {
            // FX15 set delay timer = VX
            delay_timer = V[x]
        } else if nn == 0x18 {
            // FX18 set sound timer = VX
            sound_timer = V[x]
        } else if nn == 0x1E {
            // FX1E I += VX
            I_reg = (I_reg + V[x]) & 0xFFF
        } else if nn == 0x29 {
            // FX29 I = address of font sprite for digit VX
            I_reg = (V[x] & 0xF) * 5
        } else if nn == 0x33 {
            // FX33 store BCD of VX at I, I+1, I+2
            let val = V[x]
            memory[I_reg] = val / 100
            memory[I_reg + 1] = (val / 10) % 10
            memory[I_reg + 2] = val % 10
        } else if nn == 0x55 {
            // FX55 store V0-VX in memory starting at I
            for i in 0..=x {
                memory[I_reg + i] = V[i]
            }
        } else if nn == 0x65 {
            // FX65 load V0-VX from memory starting at I
            for i in 0..=x {
                V[i] = memory[I_reg + i]
            }
        }
    }
}
